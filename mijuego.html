<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Auto 3D Game - Bass Boost Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            font-family: sans-serif;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            display: none;
        }

        #musicMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            color: white;
            display: none;
            min-width: 400px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        #musicMenu h2 {
            margin-top: 0;
            color: #00ff88;
            text-align: center;
        }

        #musicMenu input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #00ff88;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        }

        #musicMenu button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        #playBtn {
            background: #00ff88;
            color: black;
            font-weight: bold;
        }

        #playBtn:hover {
            background: #00cc6a;
            transform: scale(1.05);
        }

        #stopBtn {
            background: #ff4444;
            color: white;
        }

        #stopBtn:hover {
            background: #cc0000;
        }

        #closeBtn {
            background: #666;
            color: white;
        }

        #closeBtn:hover {
            background: #888;
        }

        .musicStatus {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 5px;
            text-align: center;
        }

        .volumeControl {
            margin: 15px 0;
        }

        .volumeControl label {
            display: block;
            margin-bottom: 5px;
            color: #00ff88;
        }

        .volumeControl input[type="range"] {
            width: 100%;
        }

        .bassIndicator {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 0, 100, 0.2);
            border-radius: 5px;
            text-align: center;
            color: #ff0066;
            font-weight: bold;
        }

        .loading {
            display: inline-block;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Login Menu */
        #loginMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #00ff88;
            color: white;
            min-width: 500px;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.7);
            z-index: 1000;
        }

        #loginMenu h2 {
            margin-top: 0;
            color: #00ff88;
            text-align: center;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #loginMenu input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: rgba(0, 100, 50, 0.2);
            color: white;
            font-size: 18px;
            box-sizing: border-box;
            text-align: center;
        }

        #loginMenu input:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        #joinBtn {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: black;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
        }

        #joinBtn:hover {
            background: linear-gradient(135deg, #00cc6a, #00aa55);
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.5);
        }

        /* Players Panel */
        #playersPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            color: white;
            min-width: 200px;
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        #playersPanel h3 {
            margin: 0 0 10px 0;
            color: #00ff88;
            text-align: center;
            font-size: 16px;
        }

        .player-item {
            background: rgba(0, 255, 136, 0.1);
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #00ff88;
            font-size: 14px;
        }

        .player-item.self {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        .player-name {
            font-weight: bold;
            color: #00ff88;
        }

        .player-item.self .player-name {
            color: #ffaa00;
        }

        .player-status {
            font-size: 11px;
            color: #aaa;
            margin-top: 3px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <b>Modo:</b> <span id="mode">Jugador</span><br>
        <b>Controles Jugador:</b> WASD + Mouse<br>
        <b>Controles Auto:</b> Flechas o WASD<br>
        <b>Entrar/Salir Auto:</b> E o Enter<br>
        <b>M√∫sica del Auto:</b> F<br>
        <span id="status">Cargando modelo...</span><br>
        <span id="musicInfo" style="color: #00ff88;"></span>
    </div>
    <div id="crosshair"></div>

    <!-- Login Menu -->
    <div id="loginMenu">
        <h2>üöó Car Game Online üåê</h2>
        <p style="color: #aaa; text-align: center;">Ingresa tu nombre para jugar online</p>
        <input type="text" id="playerName" placeholder="Tu nombre" maxlength="20">
        <div style="text-align: center; margin-top: 15px;">
            <button id="joinBtn">üéÆ Unirse al Juego</button>
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #888; text-align: center;">
            üí° ¬°Juega con otros jugadores en tiempo real!
        </div>
    </div>

    <!-- Players Online Panel -->
    <div id="playersPanel">
        <h3>üë• Jugadores Online</h3>
        <div id="playersList"></div>
    </div>

    <div id="musicMenu">
        <h2>üéµ Music Car - Bass Boost Radio üéµ</h2>
        <input type="text" id="musicUrl" placeholder="Pega aqu√≠ el link .mp3 de tu m√∫sica (Discord, Drive, etc.)">
        <div class="volumeControl">
            <label>Volumen M√°ximo: <span id="volumeValue">100</span>%</label>
            <input type="range" id="volumeSlider" min="0" max="100" value="100">
        </div>
        <div class="volumeControl">
            <label>Sensibilidad Bass: <span id="bassValue">50</span>%</label>
            <input type="range" id="bassSensitivity" min="0" max="100" value="50">
        </div>
        <div style="text-align: center;">
            <button id="playBtn">‚ñ∂Ô∏è Reproducir</button>
            <button id="stopBtn">‚èπÔ∏è Detener</button>
            <button id="closeBtn">‚úñÔ∏è Cerrar</button>
        </div>
        <div class="musicStatus">
            <span id="musicStatusText">No hay m√∫sica cargada</span>
        </div>
        <div class="bassIndicator">
            üîä Bass Level: <span id="bassLevel">0</span>%
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #888;">
            üí° Tip: El auto rebota con los bajos de la m√∫sica üöóüí®
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // FIREBASE IMPORTS
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, get, update as dbUpdate, onValue, remove, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCw0v9mVUpOO8HYYfHLhyzkgIMfoBljJcQ",
            authDomain: "fortnite-8012b.firebaseapp.com",
            databaseURL: "https://fortnite-8012b-default-rtdb.firebaseio.com",
            projectId: "fortnite-8012b",
            storageBucket: "fortnite-8012b.firebasestorage.app",
            messagingSenderId: "862924450554",
            appId: "1:862924450554:web:b01ab7f85afa7965c2f743",
            measurementId: "G-8Q997GYMM2"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Variables de estado multiplayer
        let currentPlayerId = null;
        let currentPlayerName = null;
        let otherPlayers = {};
        let isOnline = false;
        let lastUpdateTime = 0;
        const UPDATE_INTERVAL = 300; // actualizar cada 300ms (reducido para menos lag)

        // Para detecci√≥n de cambios
        let lastSentPosition = { x: 0, y: 0, z: 0, rotation: 0, mode: 'player' };
        const MIN_POSITION_CHANGE = 0.5; // m√≠nimo cambio de posici√≥n para enviar update
        const MIN_ROTATION_CHANGE = 0.1; // m√≠nimo cambio de rotaci√≥n para enviar update

        // Sistema de Audio DUAL - cada auto tiene su propio sistema de audio
        let audioContext = null;

        // Audio para Auto 1
        let car1Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioBuffer: null,
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };

        // Audio para Auto 2 (Cami√≥n)
        let car2Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioBuffer: null,
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };
        let car3Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioBuffer: null,
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };

        // ========================================
        // üöó CONFIGURACI√ìN DE AUTOS - ¬°EDITA AQU√ç!
        // ========================================
        // Para agregar m√°s autos, solo agrega objetos a este array:
        const carsConfig = [
            {
                id: 'car1',
                name: 'Auto 1',
                modelUrl: 'https://raw.githubusercontent.com/yoyoyogogo/juego/main/music%20car%203d%20model%20(2).glb',
                position: { x: 0, y: 1.5, z: -10 },
                rotation: { x: 0, y: -Math.PI / 2, z: 0 }, // -90¬∞ para que mire adelante como en la versi√≥n anterior
                scale: 1,
                audio: car1Audio
            },
            {
                id: 'car2',
                name: 'Cami√≥n',
                modelUrl: 'https://raw.githubusercontent.com/yoyoyogogo/camion/main/Sin_nombre.glb',
                position: { x: 15, y: 1.5, z: -10 },
                rotation: { x: 0, y: -Math.PI / 2, z: 0 }, // -90¬∞ para que mire adelante
                scale: 1,
                audio: car2Audio
            },
            {
                id: 'car3',
                name: 'Cami√≥n2',
                modelUrl: 'https://raw.githubusercontent.com/yoyoyogogo/GTR-M3-/main/racing%20car%203d%20model.glb',
                position: { x: 45, y: 1.5, z: -10 },
                rotation: { x: 0, y: 0, z: 0 }, // Ajustado para que mire hacia adelante
                scale: 1,
                audio: car3Audio
            }
            // Para agregar m√°s autos, copia y pega este bloque:
            // {
            //     id: 'car3',
            //     name: 'Auto 3',
            //     modelUrl: 'URL_DEL_MODELO.glb',
            //     position: { x: 30, y: 0, z: -10 },
            //     rotation: { x: 0, y: 0, z: 0 },
            //     scale: 2,
            //     audio: car3Audio // Necesitas crear car3Audio arriba
            // }
        ];

        // Crear elementos de audio HTML para cada auto (SIN Web Audio API - sin CORS issues)
        carsConfig.forEach(config => {
            const audioElement = document.createElement('audio');
            audioElement.loop = true;
            audioElement.volume = config.audio.maxVolume;
            audioElement.preload = 'auto';
            config.audio.audioElement = audioElement;
            console.log(`üîä Elemento de audio creado para ${config.name}`);
        });

        // Array para almacenar referencias a autos cargados
        const loadedCars = {};
        const carMusicState = {};

        // Auto activo en el men√∫ de m√∫sica
        let currentAudioTarget = null; // ID del auto ('car1', 'car2', etc)

        // YouTube Player (mantener compatibilidad)
        let youtubePlayer = null;
        let youtubePlayerReady = false;
        let currentMusicType = null; // 'audio' o 'youtube'

        // Rol en el auto
        let carRole = null; // 'driver', 'passenger', o null
        let currentCarId = null; // ID del auto en el que est√°s

        // 1. ESCENA Y RENDERER
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 150, 400);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 2. C√ÅMARA
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);

        // 3. CONTROLES DE POINTER LOCK
        const controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        let isPlayerMode = true;
        const playerSpeed = 0.15;
        const playerRadius = 0.5;
        const moveForward = { active: false };
        const moveBackward = { active: false };
        const moveLeft = { active: false };
        const moveRight = { active: false };

        document.addEventListener('click', () => {
            if (isPlayerMode && !controls.isLocked) {
                controls.lock();
            }
        });

        controls.addEventListener('lock', () => {
            document.getElementById('crosshair').style.display = 'block';
        });

        controls.addEventListener('unlock', () => {
            document.getElementById('crosshair').style.display = 'none';
        });

        // 4. LUCES
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(50, 50, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        // 5. PISO
        const floorGeo = new THREE.PlaneGeometry(1000, 1000);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x5cb85c,
            roughness: 0.8,
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // CARRETERA
        const roadGeo = new THREE.PlaneGeometry(20, 1000);
        const roadMat = new THREE.MeshStandardMaterial({
            color: 0x3d3d3d,
            roughness: 0.9,
        });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0.01;
        road.receiveShadow = true;
        scene.add(road);

        // L√≠neas amarillas
        const lineGeo = new THREE.PlaneGeometry(0.5, 10);
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffdd00 });

        for (let i = -50; i < 50; i++) {
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.rotation.x = -Math.PI / 2;
            line.position.set(0, 0.02, i * 20);
            scene.add(line);
        }

        // √Årboles
        function createTree(x, z) {
            const tree = new THREE.Group();

            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x6b4423,
                roughness: 0.9
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.5;
            trunk.castShadow = true;
            tree.add(trunk);

            const foliageGeo = new THREE.SphereGeometry(2, 8, 8);
            const foliageMat = new THREE.MeshStandardMaterial({
                color: 0x3a7d3a,
                roughness: 0.8
            });
            const foliage = new THREE.Mesh(foliageGeo, foliageMat);
            foliage.position.y = 4;
            foliage.castShadow = true;
            tree.add(foliage);

            tree.position.set(x, 0, z);
            return tree;
        }

        for (let i = 0; i < 30; i++) {
            const z = (Math.random() - 0.5) * 500;
            scene.add(createTree(-30 - Math.random() * 20, z));
            scene.add(createTree(30 + Math.random() * 20, z));
        }

        // Nubes
        function createCloud(x, y, z) {
            const cloud = new THREE.Group();
            const cloudMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                roughness: 1
            });

            for (let i = 0; i < 5; i++) {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(3 + Math.random() * 2, 8, 8),
                    cloudMat
                );
                sphere.position.set(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 8
                );
                cloud.add(sphere);
            }

            cloud.position.set(x, y, z);
            return cloud;
        }

        for (let i = 0; i < 15; i++) {
            scene.add(createCloud(
                (Math.random() - 0.5) * 300,
                30 + Math.random() * 20,
                (Math.random() - 0.5) * 300
            ));
        }

        // Flores
        function createFlower(x, z) {
            const colors = [0xff5252, 0xffeb3b, 0x00bcd4, 0xe91e63];
            const flowerGeo = new THREE.SphereGeometry(0.2, 6, 6);
            const flowerMat = new THREE.MeshStandardMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                roughness: 0.6
            });
            const flower = new THREE.Mesh(flowerGeo, flowerMat);
            flower.position.set(x, 0.2, z);
            return flower;
        }

        for (let i = 0; i < 50; i++) {
            const x = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 500;
            if (Math.abs(x) > 15) {
                scene.add(createFlower(x, z));
            }
        }

        // ========================================
        // üöó CARGA DIN√ÅMICA DE AUTOS
        // ========================================
        // Este sistema carga autom√°ticamente todos los autos del array carsConfig

        // Variables compatibles con c√≥digo legacy
        let car = null;
        let carContainer = null;
        let carCollisionBox = null;
        let carBaseY = 1.5;

        let car2 = null;
        let car2Container = null;
        let car2CollisionBox = null;
        let car2BaseY = 1.5;
        let car2Bounce = 0;

        // Variable para controlar qu√© auto est√° activo (el que est√°s manejando)
        let activeCarContainer = null;
        let activeCarCollisionBox = null;
        let activeCarBaseY = 1.5;

        // Funci√≥n para cargar un auto desde configuraci√≥n
        function loadCarFromConfig(config) {
            return new Promise((resolve, reject) => {
                console.log(`üöó Cargando ${config.name} (${config.id})...`);

                const container = new THREE.Group();
                scene.add(container);

                const loader = new GLTFLoader();

                loader.load(
                    config.modelUrl,
                    (gltf) => {
                        const model = gltf.scene;

                        // Centrar modelo
                        const box = new THREE.Box3().setFromObject(model);
                        const size = box.getSize(new THREE.Vector3()).length();
                        const center = box.getCenter(new THREE.Vector3());

                        model.position.x = -center.x;
                        model.position.z = -center.z;
                        model.position.y = -box.min.y;

                        // Aplicar rotaci√≥n de configuraci√≥n
                        model.rotation.x = config.rotation.x;
                        model.rotation.y = config.rotation.y;
                        model.rotation.z = config.rotation.z;

                        // Escalar modelo
                        const scaleFactor = (8 / size) * config.scale;
                        model.scale.set(scaleFactor, scaleFactor, scaleFactor);

                        // Habilitar sombras
                        model.traverse(n => {
                            if (n.isMesh) {
                                n.castShadow = true;
                                n.receiveShadow = true;
                            }
                        });

                        container.add(model);
                        container.position.set(config.position.x, config.position.y || 1.5, config.position.z);

                        // Calcular collision box
                        const carBox = new THREE.Box3().setFromObject(container);
                        const carSize = carBox.getSize(new THREE.Vector3());
                        const collisionBox = {
                            width: carSize.x * 0.8,
                            length: carSize.z * 0.8,
                            height: carSize.y
                        };

                        // Guardar en loadedCars
                        loadedCars[config.id] = {
                            id: config.id,
                            name: config.name,
                            model: model,
                            container: container,
                            collisionBox: collisionBox,
                            baseY: config.position.y || 1.5,
                            bounce: 0,
                            audio: config.audio
                        };

                        // Compatibilidad con c√≥digo legacy
                        if (config.id === 'car1') {
                            car = model;
                            carContainer = container;
                            carCollisionBox = collisionBox;
                            carBaseY = config.position.y || 1.5;
                        } else if (config.id === 'car2') {
                            car2 = model;
                            car2Container = container;
                            car2CollisionBox = collisionBox;
                            car2BaseY = config.position.y || 1.5;
                        }

                        console.log(`‚úÖ ${config.name} cargado!`);
                        resolve(loadedCars[config.id]);
                    },
                    (xhr) => {
                        const progress = (xhr.loaded / xhr.total * 100).toFixed(2);
                        console.log(`${config.name} cargando: ${progress}%`);
                    },
                    (error) => {
                        console.error(`‚ùå Error cargando ${config.name}:`, error);
                        reject(error);
                    }
                );
            });
        }

        // Cargar todos los autos del array de configuraci√≥n
        async function loadAllCars() {
            try {
                console.log(`üöó Cargando ${carsConfig.length} autos...`);

                const loadPromises = carsConfig.map(config => loadCarFromConfig(config));
                await Promise.all(loadPromises);

                console.log('‚úÖ Todos los autos cargados!');
                document.getElementById('status').innerText = "¬°Modelos cargados! Presiona F para la m√∫sica";
            } catch (error) {
                console.error('‚ùå Error cargando autos:', error);
                document.getElementById('status').innerText = "Error al cargar algunos autos";
            }
        }

        // Iniciar carga de autos
        loadAllCars();

        // ===== SISTEMA MULTIPLAYER =====

        // Login del jugador
        function joinGame() {
            const nameInput = document.getElementById('playerName');
            const playerName = nameInput.value.trim();

            if (!playerName) {
                alert('Por favor ingresa tu nombre');
                return;
            }

            currentPlayerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            currentPlayerName = playerName;
            isOnline = true;

            // Crear referencia del jugador en Firebase bajo carGame
            const playerRef = ref(database, `carGame/players/${currentPlayerId}`);

            // Configurar datos iniciales del jugador
            set(playerRef, {
                name: currentPlayerName,
                x: 0,
                y: 1.7,
                z: 5,
                rotation: 0,
                mode: 'player', // 'player' or 'car'
                timestamp: Date.now()
            });

            // Configurar desconexi√≥n autom√°tica
            onDisconnect(playerRef).remove();

            // Tambi√©n liberar el auto si lo ten√≠a ocupado al desconectarse
            const carOccupiedRef = ref(database, 'carGame/carOccupied');
            get(carOccupiedRef).then(snapshot => {
                if (snapshot.exists() && snapshot.val() === currentPlayerId) {
                    onDisconnect(carOccupiedRef).remove();
                }
            });

            // Ocultar menu de login y mostrar panel de jugadores
            document.getElementById('loginMenu').style.display = 'none';
            document.getElementById('playersPanel').style.display = 'block';

            // Escuchar cambios en otros jugadores
            setupPlayerListeners();

            console.log('Conectado como:', currentPlayerName);
        }

        // Configurar listeners para otros jugadores
        let playerListenersSetup = false;
        function setupPlayerListeners() {
            if (playerListenersSetup) return;
            playerListenersSetup = true;

            const playersRef = ref(database, 'carGame/players');

            onValue(playersRef, (snapshot) => {
                const players = snapshot.val();

                if (!players) {
                    updatePlayersList({});
                    return;
                }

                // Actualizar lista de jugadores
                updatePlayersList(players);

                // Actualizar modelos 3D de otros jugadores
                Object.keys(players).forEach(playerId => {
                    if (playerId !== currentPlayerId) {
                        const playerData = players[playerId];
                        updateOtherPlayer(playerId, playerData);
                    }
                });

                // Eliminar jugadores que ya no est√°n
                Object.keys(otherPlayers).forEach(playerId => {
                    if (!players[playerId]) {
                        removeOtherPlayer(playerId);
                    }
                });
            });

            // Sistema de tracking para evitar recargas innecesarias
            const loadedMusicURLs = {};
            const loadingInProgress = {}; // Prevenir cargas simult√°neas
            const lastLoadTime = {}; // Evitar recargas r√°pidas
            const carMusicState = {}; // Estado de m√∫sica por auto

            // Crear listeners din√°micos para TODOS los autos
            carsConfig.forEach(config => {
                const carMusicRef = ref(database, `carGame/${config.id}Music`);
                onValue(carMusicRef, async (snapshot) => {
                    const musicData = snapshot.val();

                    if (!musicData) {
                        // Limpiar tracking si no hay m√∫sica
                        delete loadedMusicURLs[config.id];
                        delete loadingInProgress[config.id];
                        delete lastLoadTime[config.id];
                        delete carMusicState[config.id];

                        // Detener audio HTML local para este auto
                        const audioObj = loadedCars[config.id] ? loadedCars[config.id].audio :
                            (config.id === 'car2' ? car2Audio : car1Audio);
                        if (audioObj && audioObj.audioElement) {
                            audioObj.audioElement.pause();
                            audioObj.audioElement.currentTime = 0;
                            audioObj.isPlaying = false;
                        }

                        // Actualizar UI si estamos viendo este auto
                        if (currentAudioTarget === config.id) {
                            musicStatusText.textContent = '‚è∏Ô∏è M√∫sica detenida';
                            musicInfo.textContent = '';
                            bassLevelSpan.textContent = '0';
                        }

                        return;
                    }

                    // Guardar estado de m√∫sica por auto (para rellenar men√∫ luego)
                    carMusicState[config.id] = musicData;

                    // Si YO puso esta m√∫sica, no recargarla (pero s√≠ mantenemos estado)
                    if (musicData.playerId === currentPlayerId) return;

                    // Si ya est√° cargando, esperar
                    if (loadingInProgress[config.id]) {
                        return;
                    }

                    // Si ya est√° cargada esta misma URL, no recargarla
                    if (loadedMusicURLs[config.id] === musicData.url) {
                        // Verificar que est√© reproduciendo
                        if (config.audio.audioElement && !config.audio.audioElement.paused) {
                            return; // Ya est√° reproduciendo
                        }
                    }

                    // Evitar recargas muy r√°pidas (debounce de 2 segundos)
                    const now = Date.now();
                    if (lastLoadTime[config.id] && (now - lastLoadTime[config.id]) < 2000) {
                        console.log(`‚è±Ô∏è Esperando debounce para ${config.name}...`);
                        return;
                    }

                    // Marcar como cargando
                    loadingInProgress[config.id] = true;
                    lastLoadTime[config.id] = now;

                    // Otro jugador puso m√∫sica NUEVA en este auto, reproducirla
                    try {
                        console.log(`üéµ Sincronizando m√∫sica ${config.name}`);
                        config.audio.maxVolume = musicData.volume || 1.0;
                        config.audio.bassSensitivity = musicData.bassSensitivity || 0.5;
                        await loadAudioFromURL(musicData.url, config.id);
                        playAudio(config.id);

                        // Guardar URL cargada
                        loadedMusicURLs[config.id] = musicData.url;
                    } catch (error) {
                        console.error(`‚ùå Error cargando m√∫sica ${config.name}:`, error);
                    } finally {
                        // Liberar flag de carga
                        loadingInProgress[config.id] = false;
                    }
                });

                // Crear listener para ocupantes de este auto
                const occupantsRef = ref(database, `carGame/${config.id}Occupants`);
                onValue(occupantsRef, (snapshot) => {
                    const occupants = snapshot.val();
                    // Solo log en cambios
                    if (occupants && Object.keys(occupants).length > 0) {
                        // Silencioso - no spamear consola
                    }
                });
            });
        }

        // Actualizar panel de jugadores
        function updatePlayersList(players) {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';

            let count = 0;
            Object.keys(players).forEach(playerId => {
                const player = players[playerId];
                const div = document.createElement('div');
                div.className = 'player-item' + (playerId === currentPlayerId ? ' self' : '');

                div.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div class="player-status">Modo: ${player.mode === 'player' ? 'üö∂ Jugador' : 'üöó Auto'}</div>
                `;

                playersList.appendChild(div);
                count++;
            });

            // Actualizar t√≠tulo con conteo
            document.querySelector('#playersPanel h3').textContent = `üë• Jugadores Online (${count})`;
        }

        // Crear el modelo 3D para otro jugador
        function createOtherPlayerModel(playerData) {
            const group = new THREE.Group();

            // Crear modelo simple de jugador (cilindro + esfera)
            const bodyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00aaff });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.75;
            body.castShadow = true;
            body.name = 'playerBody'; // Identificador para controlar visibilidad
            group.add(body);

            const headGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.8;
            head.castShadow = true;
            head.name = 'playerHead'; // Identificador para controlar visibilidad
            group.add(head);

            // Etiqueta con nombre
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(playerData.name, 128, 42);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(2, 0.5, 1);
            sprite.position.y = 2.5;
            sprite.name = 'playerNameTag'; // Identificador para la etiqueta
            group.add(sprite);

            return group;
        }

        // Actualizar la posici√≥n de otro jugador
        function updateOtherPlayer(playerId, playerData) {
            if (!otherPlayers[playerId]) {
                // Crear nuevo modelo si no existe
                const model = createOtherPlayerModel(playerData);
                model.position.set(playerData.x, playerData.y, playerData.z);

                // Configurar visibilidad inicial
                const body = model.getObjectByName('playerBody');
                const head = model.getObjectByName('playerHead');
                if (body) body.visible = (playerData.mode === 'player');
                if (head) head.visible = (playerData.mode === 'player');

                scene.add(model);
                otherPlayers[playerId] = {
                    model,
                    data: playerData,
                    targetPos: new THREE.Vector3(playerData.x, playerData.y, playerData.z),
                    targetRotation: playerData.rotation || 0,
                    velocity: new THREE.Vector3(0, 0, 0)
                };
            } else {
                // Actualizar posici√≥n existente con interpolaci√≥n suave mejorada
                const player = otherPlayers[playerId];

                // Mostrar/ocultar cuerpo seg√∫n el modo (el nombre siempre visible)
                const body = player.model.getObjectByName('playerBody');
                const head = player.model.getObjectByName('playerHead');
                const nameTag = player.model.getObjectByName('playerNameTag');

                if (body) body.visible = (playerData.mode === 'player');
                if (head) head.visible = (playerData.mode === 'player');
                // nameTag siempre visible

                // Si est√° en el auto, ajustar posici√≥n del nombre m√°s arriba
                if (nameTag) {
                    nameTag.position.y = (playerData.mode === 'car') ? 4 : 2.5;
                }

                // Calcular velocidad para predicci√≥n
                const oldTarget = player.targetPos.clone();
                player.targetPos.set(playerData.x, playerData.y, playerData.z);
                player.targetRotation = playerData.rotation || 0;
                const oldTimestamp = (player.data && typeof player.data.timestamp === 'number') ? player.data.timestamp : (playerData.timestamp || Date.now());
                const newTimestamp = (typeof playerData.timestamp === 'number') ? playerData.timestamp : Date.now();
                const dt = Math.max(0.001, (newTimestamp - oldTimestamp) / 1000);
                player.velocity.subVectors(player.targetPos, oldTarget).multiplyScalar(1 / dt);

                player.data = playerData;
            }
        }

        // Eliminar jugador que se desconect√≥
        function removeOtherPlayer(playerId) {
            if (otherPlayers[playerId]) {
                scene.remove(otherPlayers[playerId].model);
                delete otherPlayers[playerId];
            }
        }

        // Actualizar posici√≥n del jugador actual en Firebase
        function updateMyPosition() {
            if (!isOnline || !currentPlayerId) return;

            const now = Date.now();
            if (now - lastUpdateTime < UPDATE_INTERVAL) return;

            const playerRef = ref(database, `carGame/players/${currentPlayerId}`);

            let posX, posY, posZ, rotation, mode;

            if (isPlayerMode) {
                const pos = controls.getObject().position;
                posX = pos.x;
                posY = pos.y;
                posZ = pos.z;
                rotation = 0;
                mode = 'player';
            } else {
                // Usar el auto activo (el que realmente est√°s manejando)
                const activeCar = activeCarContainer || carContainer;
                posX = activeCar.position.x;
                posY = activeCar.position.y;
                posZ = activeCar.position.z;
                rotation = activeCar.rotation.y;
                mode = 'car';
            }

            // Solo enviar si hay cambios significativos
            const posChanged = Math.abs(posX - lastSentPosition.x) > MIN_POSITION_CHANGE ||
                Math.abs(posY - lastSentPosition.y) > MIN_POSITION_CHANGE ||
                Math.abs(posZ - lastSentPosition.z) > MIN_POSITION_CHANGE;
            const rotChanged = Math.abs(rotation - lastSentPosition.rotation) > MIN_ROTATION_CHANGE;
            const modeChanged = mode !== lastSentPosition.mode;

            // Solo actualizar si hay cambios significativos
            if (posChanged || rotChanged || modeChanged) {
                lastUpdateTime = now;
                lastSentPosition = { x: posX, y: posY, z: posZ, rotation, mode };

                dbUpdate(playerRef, {
                    x: Number(posX.toFixed(2)),
                    y: Number(posY.toFixed(2)),
                    z: Number(posZ.toFixed(2)),
                    rotation: Number(rotation.toFixed(2)),
                    mode: mode,
                    carId: currentCarId || 'car1', // ENVIAR QU√â AUTO ESTAMOS USANDO
                    timestamp: now
                });
            }
        }

        // Verificar si el auto est√° disponible (conductor o pasajero)
        async function checkCarAvailability(carId = 'car1') {
            if (!isOnline) return { canJoin: true, role: 'driver' }; // Si no est√° online, siempre disponible

            try {
                // Usar referencia separada por auto
                const carRef = ref(database, `carGame/${carId}Occupants`);
                const snapshot = await get(carRef);

                if (!snapshot.exists()) {
                    return { canJoin: true, role: 'driver' }; // Auto libre, ser conductor
                }

                const occupants = snapshot.val();
                const occupantsList = Object.values(occupants);

                // Si ya estoy en el auto, permitir
                if (occupants[currentPlayerId]) {
                    return { canJoin: true, role: occupants[currentPlayerId].role };
                }

                // L√≠mite: 1 conductor + 3 pasajeros = 4 personas m√°ximo
                if (occupantsList.length >= 4) {
                    return { canJoin: false, role: null }; // Auto lleno
                }

                // Verificar si ya hay conductor
                const hasDriver = occupantsList.some(o => o.role === 'driver');

                if (!hasDriver) {
                    return { canJoin: true, role: 'driver' }; // Ser conductor
                } else {
                    return { canJoin: true, role: 'passenger' }; // Ser pasajero
                }
            } catch (error) {
                console.error('Error verificando disponibilidad del auto:', error);
                return { canJoin: true, role: 'driver' }; // En caso de error, permitir
            }
        }

        // Event listener para el bot√≥n de login
        document.getElementById('joinBtn').addEventListener('click', joinGame);

        // Permitir Enter para unirse
        document.getElementById('playerName').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinGame();
            }
        });

        // Inicializar Web Audio API - DIN√ÅMICO para TODOS los autos
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Inicializar para TODOS los autos en carsConfig
                carsConfig.forEach(config => {
                    const audioObj = config.audio;
                    if (audioObj) {
                        audioObj.analyser = audioContext.createAnalyser();
                        audioObj.analyser.fftSize = 256;
                        const bufferLength = audioObj.analyser.frequencyBinCount;
                        audioObj.dataArray = new Uint8Array(bufferLength);
                        audioObj.gainNode = audioContext.createGain();
                        audioObj.gainNode.connect(audioContext.destination);
                    }
                });

                console.log(`üéµ Audio inicializado para ${carsConfig.length} autos`);
            }
        }

        // Cargar audio desde URL - SIMPLIFICADO con elementos HTML (¬°SIN CORS!)
        async function loadAudioFromURL(url, carId = 'car1') {
            try {
                musicStatusText.textContent = '‚è≥ Cargando m√∫sica...';
                console.log(`üéµ Configurando audio para ${carId}...`);

                // Buscar el objeto de audio correcto
                const audioObj = loadedCars[carId] ? loadedCars[carId].audio :
                    (carId === 'car2' ? car2Audio : car1Audio);

                if (!audioObj || !audioObj.audioElement) {
                    console.error(`No hay elemento de audio para ${carId}`);
                    throw new Error('No hay elemento de audio');
                }

                // Simplemente asignar la URL al elemento de audio HTML
                audioObj.audioElement.src = url;
                audioObj.audioElement.volume = audioObj.maxVolume;

                musicStatusText.textContent = '‚úÖ M√∫sica lista';
                console.log(`‚úÖ Audio configurado para ${carId}`);
                return true;
            } catch (error) {
                console.error(`‚ùå Error configurando audio para ${carId}:`, error.message);
                musicStatusText.textContent = `‚ùå Error: ${error.message}`;
                throw error;
            }
        }

        // ===== FUNCIONES DE YOUTUBE =====

        // Detectar si es un link de YouTube
        function isYouTubeURL(url) {
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?\&]v=)|youtu\.be\/)([^"\&?\/\s]{11})/;
            return youtubeRegex.test(url);
        }

        // Extraer video ID de YouTube
        function getYouTubeVideoID(url) {
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?\&]v=)|youtu\.be\/)([^"\&?\/\s]{11})/;
            const match = url.match(youtubeRegex);
            return match ? match[1] : null;
        }

        // Reproducir YouTube (simplificado)
        function playYouTube(videoID) {
            console.log('YouTube playback simplificado:', videoID);
        }

        // Detener YouTube
        function stopYouTube() {
            console.log('YouTube detenido');
        }

        // Reproducir audio - SIMPLIFICADO para elementos HTML
        function playAudio(carId = 'car1') {
            // Buscar el objeto de audio en loadedCars o usar legacy
            let audioObj;
            if (loadedCars[carId]) {
                audioObj = loadedCars[carId].audio;
            } else if (carId === 'car2') {
                audioObj = car2Audio;
            } else {
                audioObj = car1Audio;
            }

            if (!audioObj || !audioObj.audioElement) {
                console.warn(`No hay audio element para ${carId}`);
                return;
            }

            // Si ya est√° sonando, no reiniciar
            if (!audioObj.audioElement.paused) {
                console.log(`‚úì Audio ${carId} ya est√° reproduciendo`);
                return;
            }

            // Reproducir el audio HTML
            audioObj.audioElement.play().then(() => {
                audioObj.isPlaying = true;
                console.log(`üéµ Reproduciendo audio para ${carId}`);
            }).catch(err => {
                console.error(`Error reproduciendo ${carId}:`, err);
            });
        }

        // Obtener nivel de bajos - ACTUALIZADO PARA carId
        function getBassLevel(carId = 'car1') {
            const audioObj = (carId === 'car2') ? car2Audio : car1Audio;

            if (!audioObj.analyser || !audioObj.isPlaying) return 0;

            audioObj.analyser.getByteFrequencyData(audioObj.dataArray);

            // Analizar solo las frecuencias bajas (√≠ndices 0-8 aproximadamente 0-600Hz)
            let bassSum = 0;
            const bassRange = 8;
            for (let i = 0; i < bassRange; i++) {
                bassSum += audioObj.dataArray[i];
            }

            // Normalizar a 0-1
            const bassAverage = bassSum / (bassRange * 255);
            return bassAverage;
        }

        // Sistema de m√∫sica
        const musicMenu = document.getElementById('musicMenu');
        const musicUrl = document.getElementById('musicUrl');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const closeBtn = document.getElementById('closeBtn');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        const bassSensitivitySlider = document.getElementById('bassSensitivity');
        const bassValue = document.getElementById('bassValue');
        const musicStatusText = document.getElementById('musicStatusText');
        const musicInfo = document.getElementById('musicInfo');
        const bassLevelSpan = document.getElementById('bassLevel');

        volumeSlider.addEventListener('input', (e) => {
            const newVolume = e.target.value / 100;
            volumeValue.textContent = e.target.value;

            if (currentAudioTarget && loadedCars[currentAudioTarget]) {
                const audioObj = loadedCars[currentAudioTarget].audio;
                audioObj.maxVolume = newVolume;
                if (audioObj.audioElement) {
                    audioObj.audioElement.volume = newVolume;
                }
            }
        });

        bassSensitivitySlider.addEventListener('input', (e) => {
            const newSensitivity = e.target.value / 100;
            bassValue.textContent = e.target.value;

            if (currentAudioTarget) {
                const audioObj = (currentAudioTarget === 'car2') ? car2Audio : car1Audio;
                audioObj.bassSensitivity = newSensitivity;
            }
        });

        playBtn.addEventListener('click', async () => {
            const url = musicUrl.value.trim();
            if (!url) {
                alert('Por favor ingresa un link de m√∫sica');
                return;
            }

            if (!currentAudioTarget) {
                alert('Por favor ac√©rcate a un auto y presiona F primero');
                return;
            }

            try {
                initAudioContext();

                playBtn.disabled = true;
                playBtn.textContent = '‚è≥ Cargando...';

                const audioObj = (currentAudioTarget === 'car2') ? car2Audio : car1Audio;

                //Detener cualquier reproducci√≥n anterior EN ESTE AUTO
                if (audioObj.audioSource) {
                    audioObj.audioSource.stop();
                    audioObj.audioSource.disconnect();
                    audioObj.audioSource = null;
                }

                await loadAudioFromURL(url, currentAudioTarget);
                playAudio(currentAudioTarget);

                musicStatusText.textContent = 'üéµ ¬°Reproduciendo con Bass Boost!';
                musicInfo.textContent = 'üéµ M√∫sica activa - Bass detectado';
                playBtn.textContent = '‚ñ∂Ô∏è Reproducir';
                playBtn.disabled = false;

                // Guardar m√∫sica en Firebase para que todos la escuchen EN ESTE AUTO ESPEC√çFICO
                if (isOnline && currentAudioTarget) {
                    const musicPath = `carGame/${currentAudioTarget}Music`;
                    const musicRef = ref(database, musicPath);
                    set(musicRef, {
                        url: url,
                        playerId: currentPlayerId,
                        playerName: currentPlayerName,
                        timestamp: Date.now(),
                        volume: audioObj.maxVolume,
                        bassSensitivity: audioObj.bassSensitivity
                    });
                }

            } catch (error) {
                console.error('Error:', error);
                musicStatusText.textContent = '‚ùå Error al cargar m√∫sica';
                alert('No se pudo cargar la m√∫sica. Aseg√∫rate de que el link sea un archivo de audio v√°lido (.mp3, .wav, etc.)');
                playBtn.textContent = '‚ñ∂Ô∏è Reproducir';
                playBtn.disabled = false;
            }
        });

        stopBtn.addEventListener('click', () => {
            if (!currentAudioTarget) return;

            // Resolver objeto de audio del auto actual (soporta todos los autos)
            let audioObj;
            if (loadedCars[currentAudioTarget]) {
                audioObj = loadedCars[currentAudioTarget].audio;
            } else if (currentAudioTarget === 'car2') {
                audioObj = car2Audio;
            } else {
                audioObj = car1Audio;
            }

            if (!audioObj) return;

            // Detener audio Web Audio legacy si existe
            if (audioObj.audioSource) {
                audioObj.audioSource.stop();
                audioObj.audioSource.disconnect();
                audioObj.audioSource = null;
            }

            // Detener elemento de audio HTML actual
            if (audioObj.audioElement) {
                audioObj.audioElement.pause();
                audioObj.audioElement.currentTime = 0;
            }

            audioObj.isPlaying = false;
            audioObj.bounce = 0;
            if (youtubePlayer) {
                stopYouTube();
            }

            isPlaying = false;
            carBounce = 0;
            currentMusicType = null;
            musicStatusText.textContent = '‚è∏Ô∏è M√∫sica detenida';
            musicInfo.textContent = '';
            bassLevelSpan.textContent = '0';

            // Detener m√∫sica SOLO para este auto espec√≠fico en Firebase
            if (isOnline && currentAudioTarget) {
                const musicPath = `carGame/${currentAudioTarget}Music`;
                const musicRef = ref(database, musicPath);
                remove(musicRef);
            }
        });

        closeBtn.addEventListener('click', () => {
            musicMenu.style.display = 'none';
        });

        // Funci√≥n para ajustar volumen seg√∫n distancia - TODOS LOS AUTOS DIN√ÅMICAMENTE
        function updateAudioVolume() {
            // Obtener posici√≥n del jugador
            let playerPos;
            if (isPlayerMode) {
                playerPos = controls.getObject().position;
            } else if (activeCarContainer) {
                playerPos = activeCarContainer.position;
            } else {
                return;
            }

            const maxDistance = 50;
            const minDistance = 5;

            // Iterar sobre TODOS los autos cargados
            Object.values(loadedCars).forEach(carData => {
                if (carData.audio && carData.audio.audioElement) {
                    let volumeFactor = 1;

                    // Si estoy DENTRO de ESTE auto, volumen 100%
                    if (!isPlayerMode && currentCarId === carData.id) {
                        volumeFactor = 1;
                    } else if (carData.container) {
                        // Calcular por distancia
                        const dist = playerPos.distanceTo(carData.container.position);
                        if (dist <= minDistance) {
                            volumeFactor = 1;
                        } else if (dist >= maxDistance) {
                            volumeFactor = 0;
                        } else {
                            volumeFactor = 1 - (dist - minDistance) / (maxDistance - minDistance);
                        }
                    }

                    // Actualizar volumen del elemento de audio HTML
                    carData.audio.audioElement.volume = carData.audio.maxVolume * volumeFactor;
                }
            });
        }

        // Funci√≥n para hacer rebotar el auto con el bass - TODOS LOS AUTOS DIN√ÅMICAMENTE
        function updateCarBounce() {
            // Iterar sobre TODOS los autos cargados
            Object.values(loadedCars).forEach(carData => {
                if (carData.container && carData.audio) {
                    const bassLevel = getBassLevel(carData.id);
                    carData.audio.bounce = bassLevel * carData.audio.bassSensitivity;

                    // Solo aplicar rebote si es el auto activo o si estoy manej√°ndolo
                    if (activeCarContainer === carData.container || (!isPlayerMode && currentCarId === carData.id)) {
                        carData.container.position.y = carData.baseY + carData.audio.bounce * 0.5;
                    }
                }
            });

            // Actualizar UI solo si estamos viendo el men√∫ de m√∫sica
            if (currentAudioTarget && loadedCars[currentAudioTarget]) {
                const carData = loadedCars[currentAudioTarget];
                const bassLevel = getBassLevel(currentAudioTarget);
                bassLevelSpan.textContent = Math.floor(bassLevel * 100);
            }
        }


        function checkCarCollision(newPosition) {
            if (!isPlayerMode) return false;

            const playerRadius = 0.5;

            // Verificar colisi√≥n con TODOS los autos din√°micamente
            for (const carData of Object.values(loadedCars)) {
                if (carData.collisionBox && carData.container) {
                    const carPos = carData.container.position;
                    const carRot = carData.container.rotation.y;

                    const dx = newPosition.x - carPos.x;
                    const dz = newPosition.z - carPos.z;

                    const localX = dx * Math.cos(-carRot) - dz * Math.sin(-carRot);
                    const localZ = dx * Math.sin(-carRot) + dz * Math.cos(-carRot);

                    const halfWidth = carData.collisionBox.width / 2;
                    const halfLength = carData.collisionBox.length / 2;

                    if (Math.abs(localX) < halfWidth + playerRadius &&
                        Math.abs(localZ) < halfLength + playerRadius) {
                        return true; // Colisi√≥n detectada
                    }
                }
            }

            return false; // Sin colisi√≥n
        }

        // 7. CONTROLES
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (key === 'w') moveForward.active = true;
            if (key === 's') moveBackward.active = true;
            if (key === 'a') moveLeft.active = true;
            if (key === 'd') moveRight.active = true;

            if (e.key === 'ArrowUp') moveForward.active = true;
            if (e.key === 'ArrowDown') moveBackward.active = true;
            if (e.key === 'ArrowLeft') moveLeft.active = true;
            if (e.key === 'ArrowRight') moveRight.active = true;

            if (key === 'f') {
                // Detectar auto m√°s cercano para abrir su men√∫ de m√∫sica
                const playerPos = controls.getObject().position;

                let closestCar = null;
                let closestDistance = Infinity;

                // Buscar en todos los autos cargados
                Object.values(loadedCars).forEach(carData => {
                    if (carData.container) {
                        const distance = playerPos.distanceTo(carData.container.position);
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestCar = carData;
                        }
                    }
                });

                // Solo abrir si est√°s cerca de un auto (dentro de 10 unidades)
                if (closestDistance < 10 && closestCar) {
                    currentAudioTarget = closestCar.id;
                    document.querySelector('#musicMenu h2').textContent = `üéµ Radio ${closestCar.name} - Bass Boost üéµ`;
                }

                if (musicMenu.style.display === 'none' || !musicMenu.style.display) {
                    musicMenu.style.display = 'block';
                    controls.unlock();
                } else {
                    musicMenu.style.display = 'none';
                }
            }

            if ((key === 'e' || e.key === 'Enter') && Object.keys(loadedCars).length > 0) {
                const playerPos = controls.getObject().position;

                // Funci√≥n para encontrar el auto m√°s cercano din√°micamente
                function getClosestCar() {
                    let closestCar = null;
                    let closestDistance = Infinity;

                    Object.values(loadedCars).forEach(carData => {
                        if (carData.container) {
                            const distance = playerPos.distanceTo(carData.container.position);
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestCar = carData;
                            }
                        }
                    });

                    return { car: closestCar, distance: closestDistance };
                }

                const { car: selectedCarData, distance: closestDistance } = getClosestCar();

                if (isPlayerMode && selectedCarData && closestDistance < 5) {
                    // Intentar subir al auto m√°s cercano
                    checkCarAvailability(selectedCarData.id).then(result => {
                        if (!result.canJoin) {
                            document.getElementById('status').innerText = '‚ùå Auto lleno (m√°ximo 4 personas)';
                            setTimeout(() => {
                                document.getElementById('status').innerText = 'Modo Jugador - F para m√∫sica';
                            }, 2000);
                            return;
                        }

                        // Subirse al auto con el rol asignado
                        carRole = result.role;
                        currentCarId = selectedCarData.id;
                        isPlayerMode = false;

                        // Establecer el auto activo
                        activeCarContainer = selectedCarData.container;
                        activeCarCollisionBox = selectedCarData.collisionBox;
                        activeCarBaseY = selectedCarData.baseY;

                        // Actualizar variables legacy si es car1 o car2
                        if (selectedCarData.id === 'car1') {
                            carContainer = selectedCarData.container;
                            carCollisionBox = selectedCarData.collisionBox;
                            carBaseY = selectedCarData.baseY;
                        } else if (selectedCarData.id === 'car2') {
                            car2Container = selectedCarData.container;
                            car2CollisionBox = selectedCarData.collisionBox;
                            car2BaseY = selectedCarData.baseY;
                        }

                        controls.unlock();
                        carSpeed = 0;
                        carRotation = selectedCarData.container.rotation.y;

                        const camPos = controls.getObject().position.clone();
                        scene.remove(controls.getObject());
                        camera.position.copy(camPos);
                        scene.add(camera);

                        if (carRole === 'driver') {
                            document.getElementById('mode').innerText = `${selectedCarData.name} (Conductor)`;
                            document.getElementById('status').innerText = 'üöó Manejando - F para m√∫sica';
                        } else {
                            document.getElementById('mode').innerText = `${selectedCarData.name} (Pasajero)`;
                            document.getElementById('status').innerText = 'ü™ë Pasajero - Solo disfrutas el viaje';
                        }

                        // Registrar en Firebase
                        if (isOnline) {
                            const occupantRef = ref(database, `carGame/${selectedCarData.id}Occupants/${currentPlayerId}`);
                            set(occupantRef, {
                                playerId: currentPlayerId,
                                playerName: currentPlayerName,
                                role: carRole,
                                carId: selectedCarData.id,
                                timestamp: Date.now()
                            });
                            onDisconnect(occupantRef).remove();
                        }
                    });
                } else if (!isPlayerMode && activeCarContainer) {
                    // Bajarse del auto
                    isPlayerMode = true;
                    carRole = null;
                    const wasCarId = currentCarId; // Guardar antes de resetear
                    currentCarId = null;

                    // Calcular posici√≥n segura FUERA del auto (m√°s lejos para evitar colisi√≥n)
                    const safeDistance = 6; // Distancia segura fuera del auto
                    const carRotation = activeCarContainer.rotation.y;

                    // Posicionar al jugador a un lado del auto
                    const exitX = activeCarContainer.position.x + Math.cos(carRotation) * safeDistance;
                    const exitZ = activeCarContainer.position.z + Math.sin(carRotation) * safeDistance;

                    scene.remove(camera);
                    controls.getObject().position.set(
                        exitX,
                        1.7,
                        exitZ
                    );
                    scene.add(controls.getObject());

                    document.getElementById('mode').innerText = 'Jugador';
                    document.getElementById('status').innerText = 'Modo Jugador - F para m√∫sica';

                    // Resetear auto activo
                    activeCarContainer = null;
                    activeCarCollisionBox = null;

                    // Eliminar de Firebase DE LA REFERENCIA CORRECTA
                    if (isOnline) {
                        remove(ref(database, `carGame/${wasCarId}Occupants/${currentPlayerId}`));
                    }
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();

            if (key === 'w') moveForward.active = false;
            if (key === 's') moveBackward.active = false;
            if (key === 'a') moveLeft.active = false;
            if (key === 'd') moveRight.active = false;

            if (e.key === 'ArrowUp') moveForward.active = false;
            if (e.key === 'ArrowDown') moveBackward.active = false;
            if (e.key === 'ArrowLeft') moveLeft.active = false;
            if (e.key === 'ArrowRight') moveRight.active = false;
        });

        let carSpeed = 0;
        let carRotation = 0;

        let frameDelta = 1 / 60;
        let lastFrameTime = performance.now();
        const carNetVelocity = new THREE.Vector3(0, 0, 0);
        const CAR_NET_SPRING = 55;
        const CAR_NET_DAMPING = 12;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Funci√≥n para interpolar suavemente otros jugadores
        function interpolateOtherPlayers() {
            // Rastrear QU√â JUGADOR est√° manejando QU√â AUTO din√°micamente
            const carDrivingData = {};

            Object.keys(otherPlayers).forEach(playerId => {
                const player = otherPlayers[playerId];
                if (player.targetPos && player.model) {
                    const lerpFactor = 0.15;

                    // Aplicar velocidad para predicci√≥n
                    const predictedPos = player.targetPos.clone().add(player.velocity.clone().multiplyScalar(0.12));

                    // Interpolar posici√≥n del jugador caminando
                    player.model.position.lerp(predictedPos, lerpFactor);

                    // Si est√° en modo auto, guardar datos para ESTE auto espec√≠fico
                    if (player.data.mode === 'car') {
                        const playerCarId = player.data.carId || 'car1';
                        carDrivingData[playerCarId] = {
                            pos: predictedPos,
                            targetPos: player.targetPos,
                            predictedPos: predictedPos,
                            rotation: player.targetRotation,
                            carId: playerCarId
                        };
                    }

                    // Reducir velocidad gradualmente
                    player.velocity.multiplyScalar(0.9);
                }
            });

            // Controlar TODOS los autos din√°micamente
            Object.values(loadedCars).forEach(carData => {
                if (carData.container) {
                    // Si YO estoy manejando ESTE auto, no sobre-escribir
                    if (!isPlayerMode && carRole === 'driver' && currentCarId === carData.id) {
                        // YO lo manejo, skip
                    } else if (carDrivingData[carData.id]) {
                        // OTRO jugador lo est√° manejando
                        const drivingData = carDrivingData[carData.id];
                        const carTarget = drivingData.predictedPos || drivingData.targetPos;

                        const dx = carTarget.x - carData.container.position.x;
                        const dz = carTarget.z - carData.container.position.z;

                        carNetVelocity.x += dx * CAR_NET_SPRING * frameDelta;
                        carNetVelocity.z += dz * CAR_NET_SPRING * frameDelta;

                        const dampingFactor = Math.exp(-CAR_NET_DAMPING * frameDelta);
                        carNetVelocity.x *= dampingFactor;
                        carNetVelocity.z *= dampingFactor;

                        carData.container.position.x += carNetVelocity.x * frameDelta;
                        carData.container.position.z += carNetVelocity.z * frameDelta;

                        const currentRot = carData.container.rotation.y;
                        const targetRot = drivingData.rotation;
                        let rotDiff = targetRot - currentRot;
                        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                        carData.container.rotation.y = currentRot + rotDiff * 0.15;
                    }
                }
            });
        }

        // 8. LOOP DE ANIMACI√ìN
        function update() {
            requestAnimationFrame(update);

            const now = performance.now();
            frameDelta = Math.min(0.05, (now - lastFrameTime) / 1000);
            lastFrameTime = now;

            if (isPlayerMode) {
                direction.z = Number(moveForward.active) - Number(moveBackward.active);
                direction.x = Number(moveRight.active) - Number(moveLeft.active);
                direction.normalize();

                if (moveForward.active || moveBackward.active) {
                    velocity.z = direction.z * playerSpeed;
                } else {
                    velocity.z = 0;
                }

                if (moveLeft.active || moveRight.active) {
                    velocity.x = direction.x * playerSpeed;
                } else {
                    velocity.x = 0;
                }

                const currentPos = controls.getObject().position.clone();

                controls.moveRight(velocity.x);
                controls.moveForward(velocity.z);

                const newPos = controls.getObject().position;
                if (checkCarCollision(newPos)) {
                    controls.getObject().position.copy(currentPos);
                }

                controls.getObject().position.y = 1.7;

                // Mostrar mensaje si est√° cerca de alg√∫n auto
                let closestCar = null;
                let closestDistance = Infinity;

                // Buscar el auto m√°s cercano din√°micamente
                Object.values(loadedCars).forEach(carData => {
                    if (carData.container) {
                        const distance = controls.getObject().position.distanceTo(carData.container.position);
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestCar = carData;
                        }
                    }
                });

                if (closestDistance < 5 && closestCar) {
                    document.getElementById('status').innerText = `Presiona E para entrar al ${closestCar.name}`;
                } else if (document.getElementById('status').innerText.includes('Presiona E')) {
                    document.getElementById('status').innerText = 'Modo Jugador - F para m√∫sica';
                }


            } else {
                if (activeCarContainer && carRole === 'driver') {
                    // Solo el conductor puede controlar el auto
                    if (moveForward.active) carSpeed += 0.01;
                    if (moveBackward.active) carSpeed -= 0.01;
                    if (moveLeft.active) carRotation += 0.03;
                    if (moveRight.active) carRotation -= 0.03;

                    carSpeed *= 0.95;

                    activeCarContainer.rotation.y = carRotation;
                    activeCarContainer.position.x += Math.sin(carRotation) * carSpeed;
                    activeCarContainer.position.z += Math.cos(carRotation) * carSpeed;

                    const camOffset = new THREE.Vector3(
                        activeCarContainer.position.x - Math.sin(carRotation) * 12,
                        activeCarContainer.position.y + 5,
                        activeCarContainer.position.z - Math.cos(carRotation) * 12
                    );
                    camera.position.lerp(camOffset, 0.1);
                    camera.lookAt(activeCarContainer.position);
                } else if (activeCarContainer && carRole === 'passenger') {
                    // Pasajero: c√°mara sigue el auto pero no controla
                    carSpeed *= 0.95;
                    carRotation = activeCarContainer.rotation.y;

                    const camOffset = new THREE.Vector3(
                        activeCarContainer.position.x - Math.sin(carRotation) * 12,
                        activeCarContainer.position.y + 5,
                        activeCarContainer.position.z - Math.cos(carRotation) * 12
                    );
                    camera.position.lerp(camOffset, 0.1);
                    camera.lookAt(activeCarContainer.position);
                }
            }

            // Actualizar efectos de audio
            updateAudioVolume();
            updateCarBounce();

            // Interpolar posiciones de otros jugadores para movimiento suave
            interpolateOtherPlayers();

            // Actualizar posici√≥n en multiplayer
            updateMyPosition();

            renderer.render(scene, camera);
        }

        update();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>

</html>