<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Auto 3D Game - Bass Boost Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            font-family: sans-serif;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            display: none;
        }

        #musicMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            color: white;
            display: none;
            min-width: 400px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        #musicMenu h2 {
            margin-top: 0;
            color: #00ff88;
            text-align: center;
        }

        #musicMenu input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #00ff88;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        }

        #musicMenu button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        #playBtn {
            background: #00ff88;
            color: black;
            font-weight: bold;
        }

        #playBtn:hover {
            background: #00cc6a;
            transform: scale(1.05);
        }

        #stopBtn {
            background: #ff4444;
            color: white;
        }

        #stopBtn:hover {
            background: #cc0000;
        }

        #closeBtn {
            background: #666;
            color: white;
        }

        #closeBtn:hover {
            background: #888;
        }

        .musicStatus {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 5px;
            text-align: center;
        }

        .volumeControl {
            margin: 15px 0;
        }

        .volumeControl label {
            display: block;
            margin-bottom: 5px;
            color: #00ff88;
        }

        .volumeControl input[type="range"] {
            width: 100%;
        }

        .bassIndicator {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 0, 100, 0.2);
            border-radius: 5px;
            text-align: center;
            color: #ff0066;
            font-weight: bold;
        }

        .loading {
            display: inline-block;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Login Menu */
        #loginMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #00ff88;
            color: white;
            min-width: 500px;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.7);
            z-index: 1000;
        }

        #loginMenu h2 {
            margin-top: 0;
            color: #00ff88;
            text-align: center;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #loginMenu input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: rgba(0, 100, 50, 0.2);
            color: white;
            font-size: 18px;
            box-sizing: border-box;
            text-align: center;
        }

        #loginMenu input:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        #joinBtn {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: black;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
        }

        #joinBtn:hover {
            background: linear-gradient(135deg, #00cc6a, #00aa55);
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.5);
        }

        /* Players Panel */
        #playersPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            color: white;
            min-width: 200px;
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        #playersPanel h3 {
            margin: 0 0 10px 0;
            color: #00ff88;
            text-align: center;
            font-size: 16px;
        }

        .player-item {
            background: rgba(0, 255, 136, 0.1);
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #00ff88;
            font-size: 14px;
        }

        .player-item.self {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        .player-name {
            font-weight: bold;
            color: #00ff88;
        }

        .player-item.self .player-name {
            color: #ffaa00;
        }

        .player-status {
            font-size: 11px;
            color: #aaa;
            margin-top: 3px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <b>Modo:</b> <span id="mode">Jugador</span><br>
        <b>Controles Jugador:</b> WASD + Mouse<br>
        <b>Controles Auto:</b> Flechas o WASD<br>
        <b>Entrar/Salir Auto:</b> E o Enter<br>
        <b>M√∫sica del Auto:</b> F<br>
        <span id="status">Cargando modelo...</span><br>
        <span id="musicInfo" style="color: #00ff88;"></span>
    </div>
    <div id="crosshair"></div>

    <!-- Login Menu -->
    <div id="loginMenu">
        <h2>üöó Car Game Online üåê</h2>
        <p style="color: #aaa; text-align: center;">Ingresa tu nombre para jugar online</p>
        <input type="text" id="playerName" placeholder="Tu nombre" maxlength="20">
        <div style="text-align: center; margin-top: 15px;">
            <button id="joinBtn">üéÆ Unirse al Juego</button>
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #888; text-align: center;">
            üí° ¬°Juega con otros jugadores en tiempo real!
        </div>
    </div>

    <!-- Players Online Panel -->
    <div id="playersPanel">
        <h3>üë• Jugadores Online</h3>
        <div id="playersList"></div>
    </div>

    <div id="musicMenu">
        <h2>üéµ Music Car - Bass Boost Radio üéµ</h2>
        <input type="text" id="musicUrl" placeholder="Link de YouTube o .mp3 (Discord, Drive, etc.)">
        <div class="volumeControl">
            <label>Volumen M√°ximo: <span id="volumeValue">100</span>%</label>
            <input type="range" id="volumeSlider" min="0" max="100" value="100">
        </div>
        <div class="volumeControl">
            <label>Sensibilidad Bass: <span id="bassValue">50</span>%</label>
            <input type="range" id="bassSensitivity" min="0" max="100" value="50">
        </div>
        <div style="text-align: center;">
            <button id="playBtn">‚ñ∂Ô∏è Reproducir</button>
            <button id="stopBtn">‚èπÔ∏è Detener</button>
            <button id="closeBtn">‚úñÔ∏è Cerrar</button>
        </div>
        <div class="musicStatus">
            <span id="musicStatusText">No hay m√∫sica cargada</span>
        </div>
        <div class="bassIndicator">
            üîä Bass Level: <span id="bassLevel">0</span>%
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #888;">
            üí° Tip: El auto rebota con los bajos de la m√∫sica üöóüí®
        </div>
    </div>

    <!-- YouTube Player (oculto) - iframe simple -->
    <iframe id="youtubePlayer"
        style="position: absolute; top: -9999px; left: -9999px; width: 1px; height: 1px; border: none;"
        allow="autoplay">
    </iframe>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // FIREBASE IMPORTS
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, get, update as dbUpdate, onValue, remove, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCw0v9mVUpOO8HYYfHLhyzkgIMfoBljJcQ",
            authDomain: "fortnite-8012b.firebaseapp.com",
            databaseURL: "https://fortnite-8012b-default-rtdb.firebaseio.com",
            projectId: "fortnite-8012b",
            storageBucket: "fortnite-8012b.firebasestorage.app",
            messagingSenderId: "862924450554",
            appId: "1:862924450554:web:b01ab7f85afa7965c2f743",
            measurementId: "G-8Q997GYMM2"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Variables de estado multiplayer
        let currentPlayerId = null;
        let currentPlayerName = null;
        let otherPlayers = {};
        let isOnline = false;
        let lastUpdateTime = 0;
        const UPDATE_INTERVAL = 300; // actualizar cada 300ms (reducido para menos lag)

        // Para detecci√≥n de cambios
        let lastSentPosition = { x: 0, y: 0, z: 0, rotation: 0, mode: 'player' };
        const MIN_POSITION_CHANGE = 0.5; // m√≠nimo cambio de posici√≥n para enviar update
        const MIN_ROTATION_CHANGE = 0.1; // m√≠nimo cambio de rotaci√≥n para enviar update

        // Sistema de Audio con an√°lisis de frecuencias
        let audioContext = null;
        let analyser = null;
        let dataArray = null;
        let audioSource = null;
        let audioBuffer = null;
        let maxVolume = 1.0;
        let isPlaying = false;
        let bassSensitivity = 0.5;
        let gainNode = null;

        // YouTube Player
        let youtubePlayer = null;
        let youtubePlayerReady = false;
        let currentMusicType = null; // 'audio' o 'youtube'

        // 1. ESCENA Y RENDERER
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 150, 400);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 2. C√ÅMARA
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);

        // 3. CONTROLES DE POINTER LOCK
        const controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        let isPlayerMode = true;
        const playerSpeed = 0.15;
        const playerRadius = 0.5;
        const moveForward = { active: false };
        const moveBackward = { active: false };
        const moveLeft = { active: false };
        const moveRight = { active: false };

        document.addEventListener('click', () => {
            if (isPlayerMode && !controls.isLocked) {
                controls.lock();
            }
        });

        controls.addEventListener('lock', () => {
            document.getElementById('crosshair').style.display = 'block';
        });

        controls.addEventListener('unlock', () => {
            document.getElementById('crosshair').style.display = 'none';
        });

        // 4. LUCES
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(50, 50, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        // 5. PISO
        const floorGeo = new THREE.PlaneGeometry(1000, 1000);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x5cb85c,
            roughness: 0.8,
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // CARRETERA
        const roadGeo = new THREE.PlaneGeometry(20, 1000);
        const roadMat = new THREE.MeshStandardMaterial({
            color: 0x3d3d3d,
            roughness: 0.9,
        });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0.01;
        road.receiveShadow = true;
        scene.add(road);

        // L√≠neas amarillas
        const lineGeo = new THREE.PlaneGeometry(0.5, 10);
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffdd00 });

        for (let i = -50; i < 50; i++) {
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.rotation.x = -Math.PI / 2;
            line.position.set(0, 0.02, i * 20);
            scene.add(line);
        }

        // √Årboles
        function createTree(x, z) {
            const tree = new THREE.Group();

            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x6b4423,
                roughness: 0.9
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.5;
            trunk.castShadow = true;
            tree.add(trunk);

            const foliageGeo = new THREE.SphereGeometry(2, 8, 8);
            const foliageMat = new THREE.MeshStandardMaterial({
                color: 0x3a7d3a,
                roughness: 0.8
            });
            const foliage = new THREE.Mesh(foliageGeo, foliageMat);
            foliage.position.y = 4;
            foliage.castShadow = true;
            tree.add(foliage);

            tree.position.set(x, 0, z);
            return tree;
        }

        for (let i = 0; i < 30; i++) {
            const z = (Math.random() - 0.5) * 500;
            scene.add(createTree(-30 - Math.random() * 20, z));
            scene.add(createTree(30 + Math.random() * 20, z));
        }

        // Nubes
        function createCloud(x, y, z) {
            const cloud = new THREE.Group();
            const cloudMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                roughness: 1
            });

            for (let i = 0; i < 5; i++) {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(3 + Math.random() * 2, 8, 8),
                    cloudMat
                );
                sphere.position.set(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 8
                );
                cloud.add(sphere);
            }

            cloud.position.set(x, y, z);
            return cloud;
        }

        for (let i = 0; i < 15; i++) {
            scene.add(createCloud(
                (Math.random() - 0.5) * 300,
                30 + Math.random() * 20,
                (Math.random() - 0.5) * 300
            ));
        }

        // Flores
        function createFlower(x, z) {
            const colors = [0xff5252, 0xffeb3b, 0x00bcd4, 0xe91e63];
            const flowerGeo = new THREE.SphereGeometry(0.2, 6, 6);
            const flowerMat = new THREE.MeshStandardMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                roughness: 0.6
            });
            const flower = new THREE.Mesh(flowerGeo, flowerMat);
            flower.position.set(x, 0.2, z);
            return flower;
        }

        for (let i = 0; i < 50; i++) {
            const x = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 500;
            if (Math.abs(x) > 15) {
                scene.add(createFlower(x, z));
            }
        }

        // 6. CARGA DEL AUTO
        let car = null;
        let carContainer = new THREE.Group();
        let carCollisionBox = null;
        let carBaseY = 1.5;
        let carBounce = 0;
        scene.add(carContainer);

        const loader = new GLTFLoader();
        const modelURL = 'https://raw.githubusercontent.com/yoyoyogogo/juego/main/music%20car%203d%20model%20(2).glb';

        loader.load(modelURL, (gltf) => {
            car = gltf.scene;

            const box = new THREE.Box3().setFromObject(car);
            const size = box.getSize(new THREE.Vector3()).length();
            const center = box.getCenter(new THREE.Vector3());

            car.position.x = -center.x;
            car.position.z = -center.z;
            car.position.y = -box.min.y;

            car.rotation.y = -Math.PI / 2;

            const scaleFactor = 8 / size;
            car.scale.set(scaleFactor, scaleFactor, scaleFactor);

            car.traverse(n => {
                if (n.isMesh) {
                    n.castShadow = true;
                    n.receiveShadow = true;
                }
            });

            carContainer.add(car);
            carContainer.position.set(0, carBaseY, -10);

            const carBox = new THREE.Box3().setFromObject(carContainer);
            const carSize = carBox.getSize(new THREE.Vector3());
            carCollisionBox = {
                width: carSize.x * 0.8,
                length: carSize.z * 0.8,
                height: carSize.y
            };

            document.getElementById('status').innerText = "¬°Modelo cargado! Presiona F para la m√∫sica";
        },

            (xhr) => { console.log((xhr.loaded / xhr.total * 100) + '% cargado'); },
            (error) => {
                console.error(error);
                document.getElementById('status').innerText = "Error cargando modelo";
            });

        // ===== SISTEMA MULTIPLAYER =====

        // Login del jugador
        function joinGame() {
            const nameInput = document.getElementById('playerName');
            const playerName = nameInput.value.trim();

            if (!playerName) {
                alert('Por favor ingresa tu nombre');
                return;
            }

            currentPlayerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            currentPlayerName = playerName;
            isOnline = true;

            // Crear referencia del jugador en Firebase bajo carGame
            const playerRef = ref(database, `carGame/players/${currentPlayerId}`);

            // Configurar datos iniciales del jugador
            set(playerRef, {
                name: currentPlayerName,
                x: 0,
                y: 1.7,
                z: 5,
                rotation: 0,
                mode: 'player', // 'player' or 'car'
                timestamp: Date.now()
            });

            // Configurar desconexi√≥n autom√°tica
            onDisconnect(playerRef).remove();

            // Tambi√©n liberar el auto si lo ten√≠a ocupado al desconectarse
            const carOccupiedRef = ref(database, 'carGame/carOccupied');
            get(carOccupiedRef).then(snapshot => {
                if (snapshot.exists() && snapshot.val() === currentPlayerId) {
                    onDisconnect(carOccupiedRef).remove();
                }
            });

            // Ocultar menu de login y mostrar panel de jugadores
            document.getElementById('loginMenu').style.display = 'none';
            document.getElementById('playersPanel').style.display = 'block';

            // Escuchar cambios en otros jugadores
            setupPlayerListeners();

            console.log('Conectado como:', currentPlayerName);
        }

        // Configurar listeners para otros jugadores
        function setupPlayerListeners() {
            const playersRef = ref(database, 'carGame/players');

            onValue(playersRef, (snapshot) => {
                const players = snapshot.val();

                if (!players) {
                    updatePlayersList({});
                    return;
                }

                // Actualizar lista de jugadores
                updatePlayersList(players);

                // Actualizar modelos 3D de otros jugadores
                Object.keys(players).forEach(playerId => {
                    if (playerId !== currentPlayerId) {
                        const playerData = players[playerId];
                        updateOtherPlayer(playerId, playerData);
                    }
                });

                // Eliminar jugadores que ya no est√°n
                Object.keys(otherPlayers).forEach(playerId => {
                    if (!players[playerId]) {
                        removeOtherPlayer(playerId);
                    }
                });
            });

            // Escuchar cambios en la m√∫sica compartida
            const musicRef = ref(database, 'carGame/currentMusic');
            onValue(musicRef, async (snapshot) => {
                const musicData = snapshot.val();

                if (!musicData) {
                    // No hay m√∫sica, detener si est√° reproduciendo
                    if (isPlaying && audioSource) {
                        audioSource.stop();
                        audioSource.disconnect();
                        audioSource = null;
                    }
                    if (youtubePlayer) {
                        stopYouTube();
                    }
                    isPlaying = false;
                    carBounce = 0;
                    currentMusicType = null;
                    musicInfo.textContent = '';
                    bassLevelSpan.textContent = '0';
                    return;
                }

                // Si otro jugador puso m√∫sica, reproducirla
                if (musicData.playerId !== currentPlayerId && musicData.url) {
                    try {
                        // Actualizar UI
                        musicUrl.value = musicData.url;
                        maxVolume = musicData.volume || 1.0;
                        bassSensitivity = musicData.bassSensitivity || 0.5;
                        volumeSlider.value = Math.round(maxVolume * 100);
                        volumeValue.textContent = Math.round(maxVolume * 100);
                        bassSensitivitySlider.value = Math.round(bassSensitivity * 100);
                        bassValue.textContent = Math.round(bassSensitivity * 100);

                        // Detectar tipo de m√∫sica
                        if (musicData.type === 'youtube') {
                            const videoID = getYouTubeVideoID(musicData.url);
                            if (videoID) {
                                playYouTube(videoID);
                                musicInfo.textContent = `üéµ ${musicData.playerName} est√° reproduciendo YouTube`;
                            }
                        } else {
                            // Audio normal
                            initAudioContext();
                            await loadAudioFromURL(musicData.url);
                            playAudio();
                            currentMusicType = 'audio';
                            musicInfo.textContent = `üéµ ${musicData.playerName} est√° reproduciendo m√∫sica`;
                        }
                    } catch (error) {
                        console.error('Error cargando m√∫sica compartida:', error);
                        musicInfo.textContent = '‚ùå Error cargando m√∫sica compartida';
                    }
                }
            });
        }

        // Actualizar panel de jugadores
        function updatePlayersList(players) {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';

            let count = 0;
            Object.keys(players).forEach(playerId => {
                const player = players[playerId];
                const div = document.createElement('div');
                div.className = 'player-item' + (playerId === currentPlayerId ? ' self' : '');

                div.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div class="player-status">Modo: ${player.mode === 'player' ? 'üö∂ Jugador' : 'üöó Auto'}</div>
                `;

                playersList.appendChild(div);
                count++;
            });

            // Actualizar t√≠tulo con conteo
            document.querySelector('#playersPanel h3').textContent = `üë• Jugadores Online (${count})`;
        }

        // Crear el modelo 3D para otro jugador
        function createOtherPlayerModel(playerData) {
            const group = new THREE.Group();

            // Crear modelo simple de jugador (cilindro + esfera)
            const bodyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00aaff });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.75;
            body.castShadow = true;
            body.name = 'playerBody'; // Identificador para controlar visibilidad
            group.add(body);

            const headGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.8;
            head.castShadow = true;
            head.name = 'playerHead'; // Identificador para controlar visibilidad
            group.add(head);

            // Etiqueta con nombre
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(playerData.name, 128, 42);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(2, 0.5, 1);
            sprite.position.y = 2.5;
            sprite.name = 'playerNameTag'; // Identificador para la etiqueta
            group.add(sprite);

            return group;
        }

        // Actualizar la posici√≥n de otro jugador
        function updateOtherPlayer(playerId, playerData) {
            if (!otherPlayers[playerId]) {
                // Crear nuevo modelo si no existe
                const model = createOtherPlayerModel(playerData);
                model.position.set(playerData.x, playerData.y, playerData.z);

                // Configurar visibilidad inicial
                const body = model.getObjectByName('playerBody');
                const head = model.getObjectByName('playerHead');
                if (body) body.visible = (playerData.mode === 'player');
                if (head) head.visible = (playerData.mode === 'player');

                scene.add(model);
                otherPlayers[playerId] = {
                    model,
                    data: playerData,
                    targetPos: new THREE.Vector3(playerData.x, playerData.y, playerData.z),
                    targetRotation: playerData.rotation || 0,
                    velocity: new THREE.Vector3(0, 0, 0)
                };
            } else {
                // Actualizar posici√≥n existente con interpolaci√≥n suave mejorada
                const player = otherPlayers[playerId];

                // Mostrar/ocultar cuerpo seg√∫n el modo (el nombre siempre visible)
                const body = player.model.getObjectByName('playerBody');
                const head = player.model.getObjectByName('playerHead');
                const nameTag = player.model.getObjectByName('playerNameTag');

                if (body) body.visible = (playerData.mode === 'player');
                if (head) head.visible = (playerData.mode === 'player');
                // nameTag siempre visible

                // Si est√° en el auto, ajustar posici√≥n del nombre m√°s arriba
                if (nameTag) {
                    nameTag.position.y = (playerData.mode === 'car') ? 4 : 2.5;
                }

                // Calcular velocidad para predicci√≥n
                const oldTarget = player.targetPos.clone();
                player.targetPos.set(playerData.x, playerData.y, playerData.z);
                player.targetRotation = playerData.rotation || 0;
                player.velocity.subVectors(player.targetPos, oldTarget).multiplyScalar(3);

                player.data = playerData;
            }
        }

        // Eliminar jugador que se desconect√≥
        function removeOtherPlayer(playerId) {
            if (otherPlayers[playerId]) {
                scene.remove(otherPlayers[playerId].model);
                delete otherPlayers[playerId];
            }
        }

        // Actualizar posici√≥n del jugador actual en Firebase
        function updateMyPosition() {
            if (!isOnline || !currentPlayerId) return;

            const now = Date.now();
            if (now - lastUpdateTime < UPDATE_INTERVAL) return;

            const playerRef = ref(database, `carGame/players/${currentPlayerId}`);

            let posX, posY, posZ, rotation, mode;

            if (isPlayerMode) {
                const pos = controls.getObject().position;
                posX = pos.x;
                posY = pos.y;
                posZ = pos.z;
                rotation = 0;
                mode = 'player';
            } else {
                posX = carContainer.position.x;
                posY = carContainer.position.y;
                posZ = carContainer.position.z;
                rotation = carContainer.rotation.y;
                mode = 'car';
            }

            // Solo enviar si hay cambios significativos
            const posChanged = Math.abs(posX - lastSentPosition.x) > MIN_POSITION_CHANGE ||
                Math.abs(posY - lastSentPosition.y) > MIN_POSITION_CHANGE ||
                Math.abs(posZ - lastSentPosition.z) > MIN_POSITION_CHANGE;
            const rotChanged = Math.abs(rotation - lastSentPosition.rotation) > MIN_ROTATION_CHANGE;
            const modeChanged = mode !== lastSentPosition.mode;

            // Solo actualizar si hay cambios significativos
            if (posChanged || rotChanged || modeChanged) {
                lastUpdateTime = now;
                lastSentPosition = { x: posX, y: posY, z: posZ, rotation, mode };

                dbUpdate(playerRef, {
                    x: Number(posX.toFixed(2)),
                    y: Number(posY.toFixed(2)),
                    z: Number(posZ.toFixed(2)),
                    rotation: Number(rotation.toFixed(2)),
                    mode: mode,
                    timestamp: now
                });
            }
        }

        // Verificar si el auto est√° disponible
        async function checkCarAvailability() {
            if (!isOnline) return true; // Si no est√° online, siempre disponible

            try {
                const carRef = ref(database, 'carGame/carOccupied');
                const snapshot = await get(carRef);

                if (!snapshot.exists()) {
                    return true; // Auto libre
                }

                const occupiedBy = snapshot.val();

                // Si el auto est√° ocupado por este mismo jugador, permitir
                if (occupiedBy === currentPlayerId) {
                    return true;
                }

                // Auto ocupado por otro jugador
                return false;
            } catch (error) {
                console.error('Error verificando disponibilidad del auto:', error);
                return true; // En caso de error, permitir
            }
        }

        // Event listener para el bot√≥n de login
        document.getElementById('joinBtn').addEventListener('click', joinGame);

        // Permitir Enter para unirse
        document.getElementById('playerName').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinGame();
            }
        });

        // Inicializar Web Audio API
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                gainNode = audioContext.createGain();
                gainNode.connect(audioContext.destination);
            }
        }

        // Cargar audio desde URL usando proxy CORS
        async function loadAudioFromURL(url) {
            try {
                musicStatusText.textContent = '‚è≥ Cargando m√∫sica...';

                // Usar proxy CORS para evitar problemas
                const corsProxies = [
                    'https://corsproxy.io/?',
                    'https://api.allorigins.win/raw?url=',
                    'https://cors-anywhere.herokuapp.com/'
                ];

                let audioData = null;
                let success = false;

                // Intentar cargar directamente primero
                try {
                    const directResponse = await fetch(url);
                    if (directResponse.ok) {
                        audioData = await directResponse.arrayBuffer();
                        success = true;
                    }
                } catch (e) {
                    console.log('Carga directa fall√≥, intentando con proxies...');
                }

                // Si falla, intentar con proxies
                if (!success) {
                    for (const proxy of corsProxies) {
                        try {
                            const response = await fetch(proxy + encodeURIComponent(url));
                            if (response.ok) {
                                audioData = await response.arrayBuffer();
                                success = true;
                                break;
                            }
                        } catch (e) {
                            console.log(`Proxy ${proxy} fall√≥, intentando siguiente...`);
                        }
                    }
                }

                if (!success || !audioData) {
                    throw new Error('No se pudo cargar el audio desde ninguna fuente');
                }

                musicStatusText.textContent = '‚è≥ Decodificando audio...';

                // Decodificar el audio
                audioBuffer = await audioContext.decodeAudioData(audioData);

                return true;
            } catch (error) {
                console.error('Error cargando audio:', error);
                throw error;
            }
        }

        // ===== FUNCIONES DE YOUTUBE =====

        // Detectar si es un link de YouTube
        function isYouTubeURL(url) {
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
            return youtubeRegex.test(url);
        }

        // Extraer video ID de YouTube
        function getYouTubeVideoID(url) {
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
            const match = url.match(youtubeRegex);
            return match ? match[1] : null;
        }

        // Reproducir YouTube con iframe simple
        function playYouTube(videoID) {
            const iframe = document.getElementById('youtubePlayer');
            // URL del embed con autoplay=1 y loop
            iframe.src = `https://www.youtube.com/embed/${videoID}?autoplay=1&loop=1&playlist=${videoID}&controls=0&disablekb=1&fs=0&modestbranding=1&rel=0&showinfo=0`;
            isPlaying = true;
            currentMusicType = 'youtube';
        }

        // Detener YouTube
        function stopYouTube() {
            const iframe = document.getElementById('youtubePlayer');
            iframe.src = '';
            isPlaying = false;
        }

        // Reproducir audio
        function playAudio() {
            if (audioSource) {
                audioSource.stop();
                audioSource.disconnect();
            }

            audioSource = audioContext.createBufferSource();
            audioSource.buffer = audioBuffer;
            audioSource.loop = true;

            audioSource.connect(analyser);
            analyser.connect(gainNode);

            gainNode.gain.value = maxVolume;
            audioSource.start(0);
            isPlaying = true;
        }

        // Obtener nivel de bajos
        function getBassLevel() {
            if (!analyser || !isPlaying) return 0;

            analyser.getByteFrequencyData(dataArray);

            // Analizar solo las frecuencias bajas (√≠ndices 0-8 aproximadamente 0-600Hz)
            let bassSum = 0;
            const bassRange = 8;
            for (let i = 0; i < bassRange; i++) {
                bassSum += dataArray[i];
            }

            // Normalizar a 0-1
            const bassAverage = bassSum / (bassRange * 255);
            return bassAverage;
        }

        // Sistema de m√∫sica
        const musicMenu = document.getElementById('musicMenu');
        const musicUrl = document.getElementById('musicUrl');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const closeBtn = document.getElementById('closeBtn');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        const bassSensitivitySlider = document.getElementById('bassSensitivity');
        const bassValue = document.getElementById('bassValue');
        const musicStatusText = document.getElementById('musicStatusText');
        const musicInfo = document.getElementById('musicInfo');
        const bassLevelSpan = document.getElementById('bassLevel');

        volumeSlider.addEventListener('input', (e) => {
            maxVolume = e.target.value / 100;
            volumeValue.textContent = e.target.value;
            if (gainNode) {
                gainNode.gain.value = maxVolume;
            }
        });

        bassSensitivitySlider.addEventListener('input', (e) => {
            bassSensitivity = e.target.value / 100;
            bassValue.textContent = e.target.value;
        });

        playBtn.addEventListener('click', async () => {
            const url = musicUrl.value.trim();
            if (!url) {
                alert('Por favor ingresa un link de m√∫sica');
                return;
            }

            try {
                playBtn.disabled = true;
                playBtn.textContent = '‚è≥ Cargando...';

                // Detener cualquier reproducci√≥n anterior
                if (currentMusicType === 'youtube') {
                    stopYouTube();
                } else if (currentMusicType === 'audio') {
                    if (audioSource) {
                        audioSource.stop();
                        audioSource.disconnect();
                        audioSource = null;
                    }
                }

                // Detectar si es YouTube
                if (isYouTubeURL(url)) {
                    const videoID = getYouTubeVideoID(url);
                    if (!videoID) {
                        throw new Error('No se pudo extraer el ID del video de YouTube');
                    }

                    musicStatusText.textContent = '‚è≥ Cargando desde YouTube...';
                    playYouTube(videoID);

                    musicStatusText.textContent = 'üéµ ¬°Reproduciendo desde YouTube!';
                    musicInfo.textContent = 'üéµ YouTube Music activa';
                } else {
                    // Audio normal
                    initAudioContext();
                    await loadAudioFromURL(url);
                    playAudio();
                    currentMusicType = 'audio';

                    musicStatusText.textContent = 'üéµ ¬°Reproduciendo con Bass Boost!';
                    musicInfo.textContent = 'üéµ M√∫sica activa - Bass detectado';
                }

                playBtn.textContent = '‚ñ∂Ô∏è Reproducir';
                playBtn.disabled = false;

                // Guardar m√∫sica en Firebase para que todos la escuchen
                if (isOnline) {
                    const musicRef = ref(database, 'carGame/currentMusic');
                    set(musicRef, {
                        url: url,
                        playerId: currentPlayerId,
                        playerName: currentPlayerName,
                        timestamp: Date.now(),
                        volume: maxVolume,
                        bassSensitivity: bassSensitivity,
                        type: currentMusicType
                    });
                }

            } catch (error) {
                console.error('Error:', error);
                musicStatusText.textContent = '‚ùå Error al cargar m√∫sica';
                alert('No se pudo cargar la m√∫sica. Verifica el link.');
                playBtn.textContent = '‚ñ∂Ô∏è Reproducir';
                playBtn.disabled = false;
            }
        });

        stopBtn.addEventListener('click', () => {
            // Detener audio normal
            if (audioSource) {
                audioSource.stop();
                audioSource.disconnect();
                audioSource = null;
            }

            // Detener YouTube
            if (youtubePlayer) {
                stopYouTube();
            }

            isPlaying = false;
            carBounce = 0;
            currentMusicType = null;
            musicStatusText.textContent = '‚è∏Ô∏è M√∫sica detenida';
            musicInfo.textContent = '';
            bassLevelSpan.textContent = '0';

            // Detener m√∫sica para todos
            if (isOnline) {
                const musicRef = ref(database, 'carGame/currentMusic');
                remove(musicRef);
            }
        });

        closeBtn.addEventListener('click', () => {
            musicMenu.style.display = 'none';
        });

        // Funci√≥n para ajustar volumen seg√∫n distancia al auto
        function updateAudioVolume() {
            if (!gainNode || !isPlaying) return;

            let volumeFactor = 1;

            if (isPlayerMode && carContainer) {
                const playerPos = controls.getObject().position;
                const distance = playerPos.distanceTo(carContainer.position);
                const maxDistance = 50;
                const minDistance = 5;

                if (distance <= minDistance) {
                    volumeFactor = 1;
                } else if (distance >= maxDistance) {
                    volumeFactor = 0;
                } else {
                    volumeFactor = 1 - (distance - minDistance) / (maxDistance - minDistance);
                }
            }

            gainNode.gain.value = maxVolume * volumeFactor;
        }

        // Funci√≥n para hacer rebotar el auto con el bass
        function updateCarBounce() {
            if (!carContainer) return;

            const bassLevel = getBassLevel();
            bassLevelSpan.textContent = Math.floor(bassLevel * 100);

            // Aplicar rebote basado en el nivel de bajos y sensibilidad
            const targetBounce = bassLevel * bassSensitivity * 0.8;

            // Suavizar el rebote
            carBounce += (targetBounce - carBounce) * 0.3;

            // Aplicar el rebote a la posici√≥n Y del auto
            carContainer.position.y = carBaseY + carBounce;

            // A√±adir una ligera rotaci√≥n cuando hay mucho bass
            if (bassLevel > 0.6 && bassSensitivity > 0.3) {
                const shake = Math.sin(Date.now() * 0.05) * bassLevel * 0.02;
                carContainer.rotation.z = shake;
            } else {
                carContainer.rotation.z *= 0.9;
            }
        }

        function checkCarCollision(newPosition) {
            if (!carCollisionBox || !isPlayerMode) return false;

            const carPos = carContainer.position;
            const carRot = carContainer.rotation.y;

            const dx = newPosition.x - carPos.x;
            const dz = newPosition.z - carPos.z;

            const localX = dx * Math.cos(-carRot) - dz * Math.sin(-carRot);
            const localZ = dx * Math.sin(-carRot) + dz * Math.cos(-carRot);

            const halfWidth = carCollisionBox.width / 2;
            const halfLength = carCollisionBox.length / 2;

            if (Math.abs(localX) < halfWidth + playerRadius &&
                Math.abs(localZ) < halfLength + playerRadius) {
                return true;
            }

            return false;
        }

        // 7. CONTROLES
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (key === 'w') moveForward.active = true;
            if (key === 's') moveBackward.active = true;
            if (key === 'a') moveLeft.active = true;
            if (key === 'd') moveRight.active = true;

            if (e.key === 'ArrowUp') moveForward.active = true;
            if (e.key === 'ArrowDown') moveBackward.active = true;
            if (e.key === 'ArrowLeft') moveLeft.active = true;
            if (e.key === 'ArrowRight') moveRight.active = true;

            if (key === 'f') {
                if (musicMenu.style.display === 'none' || !musicMenu.style.display) {
                    musicMenu.style.display = 'block';
                    controls.unlock();
                } else {
                    musicMenu.style.display = 'none';
                }
            }

            if ((key === 'e' || e.key === 'Enter') && car) {
                const playerPos = controls.getObject().position;
                const distance = playerPos.distanceTo(carContainer.position);

                if (isPlayerMode && distance < 5) {
                    // Verificar si el auto est√° ocupado por otro jugador
                    checkCarAvailability().then(isAvailable => {
                        if (!isAvailable) {
                            document.getElementById('status').innerText = '‚ùå Auto ocupado por otro jugador';
                            setTimeout(() => {
                                document.getElementById('status').innerText = 'Modo Jugador - F para m√∫sica';
                            }, 2000);
                            return;
                        }

                        // Auto disponible, subirse
                        isPlayerMode = false;
                        controls.unlock();
                        carSpeed = 0;
                        carRotation = carContainer.rotation.y;

                        const camPos = controls.getObject().position.clone();
                        scene.remove(controls.getObject());
                        camera.position.copy(camPos);
                        scene.add(camera);

                        document.getElementById('mode').innerText = 'Auto';
                        document.getElementById('status').innerText = 'Conduciendo - F para m√∫sica';

                        // Marcar el auto como ocupado en Firebase
                        if (isOnline) {
                            const carOccupiedRef = ref(database, 'carGame/carOccupied');
                            set(carOccupiedRef, currentPlayerId);
                            // Liberar autom√°ticamente si se desconecta
                            onDisconnect(carOccupiedRef).remove();
                        }
                    });
                } else if (!isPlayerMode) {
                    isPlayerMode = true;

                    scene.remove(camera);
                    controls.getObject().position.set(
                        carContainer.position.x + 3,
                        1.7,
                        carContainer.position.z + 3
                    );
                    scene.add(controls.getObject());

                    document.getElementById('mode').innerText = 'Jugador';
                    document.getElementById('status').innerText = 'Modo Jugador - F para m√∫sica';

                    // Liberar el auto en Firebase
                    if (isOnline) {
                        remove(ref(database, 'carGame/carOccupied'));
                    }
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();

            if (key === 'w') moveForward.active = false;
            if (key === 's') moveBackward.active = false;
            if (key === 'a') moveLeft.active = false;
            if (key === 'd') moveRight.active = false;

            if (e.key === 'ArrowUp') moveForward.active = false;
            if (e.key === 'ArrowDown') moveBackward.active = false;
            if (e.key === 'ArrowLeft') moveLeft.active = false;
            if (e.key === 'ArrowRight') moveRight.active = false;
        });

        let carSpeed = 0;
        let carRotation = 0;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Funci√≥n para interpolar suavemente otros jugadores
        function interpolateOtherPlayers() {
            let someoneElseDriving = false;
            let drivingPlayerData = null;

            Object.keys(otherPlayers).forEach(playerId => {
                const player = otherPlayers[playerId];
                if (player.targetPos && player.model) {
                    // Interpolar hacia la posici√≥n objetivo con predicci√≥n de velocidad
                    const lerpFactor = 0.15; // Factor de interpolaci√≥n m√°s suave

                    // Aplicar velocidad para predicci√≥n
                    const predictedPos = player.targetPos.clone().add(player.velocity.clone().multiplyScalar(0.1));

                    // Interpolaci√≥n suave de posici√≥n del jugador caminando
                    player.model.position.lerp(predictedPos, lerpFactor);

                    // Si est√° en modo auto, usar el auto existente
                    if (player.data.mode === 'car') {
                        someoneElseDriving = true;
                        drivingPlayerData = {
                            pos: predictedPos,
                            targetPos: player.targetPos,
                            rotation: player.targetRotation
                        };
                    }

                    // Reducir velocidad gradualmente
                    player.velocity.multiplyScalar(0.9);
                }
            });

            // Controlar el auto real seg√∫n qui√©n lo est√° manejando
            if (carContainer) {
                if (!isPlayerMode) {
                    // Yo lo estoy manejando, funciona normal
                    // No hacer nada aqu√≠
                } else if (someoneElseDriving && drivingPlayerData) {
                    // Otro jugador lo est√° manejando, mover el auto a su posici√≥n
                    carContainer.position.lerp(drivingPlayerData.targetPos, 0.15);

                    // Interpolar rotaci√≥n
                    const currentRot = carContainer.rotation.y;
                    const targetRot = drivingPlayerData.rotation;
                    let rotDiff = targetRot - currentRot;
                    if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    carContainer.rotation.y = currentRot + rotDiff * 0.15;
                }
                // Si nadie lo est√° manejando, el auto se queda donde est√°
            }
        }

        // 8. LOOP DE ANIMACI√ìN
        function update() {
            requestAnimationFrame(update);

            if (isPlayerMode) {
                direction.z = Number(moveForward.active) - Number(moveBackward.active);
                direction.x = Number(moveRight.active) - Number(moveLeft.active);
                direction.normalize();

                if (moveForward.active || moveBackward.active) {
                    velocity.z = direction.z * playerSpeed;
                } else {
                    velocity.z = 0;
                }

                if (moveLeft.active || moveRight.active) {
                    velocity.x = direction.x * playerSpeed;
                } else {
                    velocity.x = 0;
                }

                const currentPos = controls.getObject().position.clone();

                controls.moveRight(velocity.x);
                controls.moveForward(velocity.z);

                const newPos = controls.getObject().position;
                if (checkCarCollision(newPos)) {
                    controls.getObject().position.copy(currentPos);
                }

                controls.getObject().position.y = 1.7;

                if (car) {
                    const distance = controls.getObject().position.distanceTo(carContainer.position);
                    if (distance < 5) {
                        document.getElementById('status').innerText = 'Presiona E para entrar al auto';
                    } else if (document.getElementById('status').innerText.includes('Presiona E')) {
                        document.getElementById('status').innerText = 'Modo Jugador - F para m√∫sica';
                    }
                }

            } else {
                if (carContainer) {
                    if (moveForward.active) carSpeed += 0.01;
                    if (moveBackward.active) carSpeed -= 0.01;
                    if (moveLeft.active) carRotation += 0.03;
                    if (moveRight.active) carRotation -= 0.03;

                    carSpeed *= 0.95;

                    carContainer.rotation.y = carRotation;
                    carContainer.position.x += Math.sin(carRotation) * carSpeed;
                    carContainer.position.z += Math.cos(carRotation) * carSpeed;

                    const camOffset = new THREE.Vector3(
                        carContainer.position.x - Math.sin(carRotation) * 12,
                        carContainer.position.y + 5,
                        carContainer.position.z - Math.cos(carRotation) * 12
                    );
                    camera.position.lerp(camOffset, 0.1);
                    camera.lookAt(carContainer.position);
                }
            }

            // Actualizar efectos de audio
            updateAudioVolume();
            updateCarBounce();

            // Interpolar posiciones de otros jugadores para movimiento suave
            interpolateOtherPlayers();

            // Actualizar posici√≥n en multiplayer
            updateMyPosition();

            renderer.render(scene, camera);
        }

        update();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>

</html>
